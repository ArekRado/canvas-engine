<html>
  <head>
    <style>
      html {
        background-color: black;
      }
      canvas {
        width: 600px;
        height: 600px;
        border: 1px solid blue;
      }
    </style>
  </head>

  <body>
    <canvas id="demo" width="600" height="600"></canvas>

    <script>
      const canvasSize = [600, 600]
      const canvas = document.getElementById('demo')
      const ctx = canvas.getContext('2d')

      const getAABBCollision = ({
        rectangle1: [r1x1, r1y1, r1x2, r1y2],
        rectangle2: [r2x1, r2y1, r2x2, r2y2],
      }) => r1x1 <= r2x2 && r1x2 >= r2x1 && r1y1 <= r2y2 && r1y2 >= r2y1

      const emptyQuadTree = {
        topRight: null,
        topLeft: null,
        bottomRight: null,
        bottomLeft: null,
        data: [],
      }

      const flatQuadTree = (tree, maxLevel) => {
        const a = []
        if (tree.topRight) {
          const data = flatQuadTree(tree.topRight, maxLevel - 1)
          if (maxLevel === 1 && data.length > 1) {
            a.push(data)
          } else if (data[0]?.length > 1) {
            a.push(...data)
          }
        }
        if (tree.topLeft) {
          const data = flatQuadTree(tree.topLeft, maxLevel - 1)
          if (maxLevel === 1 && data.length > 1) {
            a.push(data)
          } else if (data[0]?.length > 1) {
            a.push(...data)
          }
        }
        if (tree.bottomRight) {
          const data = flatQuadTree(tree.bottomRight, maxLevel - 1)
          if (maxLevel === 1 && data.length > 1) {
            a.push(data)
          } else if (data[0]?.length > 1) {
            a.push(...data)
          }
        }
        if (tree.bottomLeft) {
          const data = flatQuadTree(tree.bottomLeft, maxLevel - 1)
          if (maxLevel === 1 && data.length > 1) {
            a.push(data)
          } else if (data[0]?.length > 1) {
            a.push(...data)
          }
        }

        return a.concat(tree.data)
      }
      const splitBounds = ({ bounds, position }) => {
        const boundHalfWidth = (bounds[2] - bounds[0]) / 2
        const boundHalfHeight = (bounds[3] - bounds[1]) / 2
        switch (position) {
          case 'topRight':
            return [
              bounds[0] + boundHalfWidth,
              bounds[1] + boundHalfHeight,
              bounds[2],
              bounds[3],
            ]
          case 'topLeft':
            return [
              bounds[0],
              bounds[1] + boundHalfHeight,
              bounds[2] - boundHalfWidth,
              bounds[3],
            ]
          case 'bottomRight':
            return [
              bounds[0] + boundHalfWidth,
              bounds[1],
              bounds[2],
              bounds[3] - boundHalfHeight,
            ]
          case 'bottomLeft':
            return [
              bounds[0],
              bounds[1],
              bounds[2] - boundHalfWidth,
              bounds[3] - boundHalfHeight,
            ]
        }
      }
      const getQuadTree = ({
        bounds,
        rectangles,
        maxLevel = 1,
        treeNode = emptyQuadTree,
      }) => {
        const isNodeEmpty =
          (treeNode.topRight === null &&
            treeNode.topLeft === null &&
            treeNode.bottomRight === null &&
            treeNode.bottomLeft === null) ||
          (treeNode.topRight?.data.length === 0 &&
            treeNode.topLeft?.data.length === 0 &&
            treeNode.bottomRight?.data.length === 0 &&
            treeNode.bottomLeft?.data.length === 0)

        if (maxLevel === 0 || (rectangles.length <= 1 && isNodeEmpty)) {
          return {
            topRight: treeNode.topRight,
            topLeft: treeNode.topLeft,
            bottomRight: treeNode.bottomRight,
            bottomLeft: treeNode.bottomLeft,
            data: rectangles,
          }
        } else {
          const newTree = rectangles.reduce((acc, data) => {
            const splittedBounds = {
              topRight: splitBounds({ bounds, position: 'topRight' }),
              topLeft: splitBounds({ bounds, position: 'topLeft' }),
              bottomRight: splitBounds({ bounds, position: 'bottomRight' }),
              bottomLeft: splitBounds({ bounds, position: 'bottomLeft' }),
            }

            const topRight = getAABBCollision({
              rectangle1: data.rectangle,
              rectangle2: splittedBounds.topRight,
            })
              ? getQuadTree({
                  bounds: splittedBounds.topRight,
                  rectangles: acc.topRight?.data.concat(data) ?? [data],
                  treeNode: acc.topRight ?? emptyQuadTree,
                  maxLevel: maxLevel - 1,
                })
              : acc.topRight

            const topLeft = getAABBCollision({
              rectangle1: data.rectangle,
              rectangle2: splittedBounds.topLeft,
            })
              ? getQuadTree({
                  bounds: splittedBounds.topLeft,
                  rectangles: acc.topLeft?.data.concat(data) ?? [data],
                  treeNode: acc.topLeft ?? emptyQuadTree,
                  maxLevel: maxLevel - 1,
                })
              : acc.topLeft

            const bottomRight = getAABBCollision({
              rectangle1: data.rectangle,
              rectangle2: splittedBounds.bottomRight,
            })
              ? getQuadTree({
                  bounds: splittedBounds.bottomRight,
                  rectangles: acc.bottomRight?.data.concat(data) ?? [data],
                  treeNode: acc.bottomRight ?? emptyQuadTree,
                  maxLevel: maxLevel - 1,
                })
              : acc.bottomRight

            const bottomLeft = getAABBCollision({
              rectangle1: data.rectangle,
              rectangle2: splittedBounds.bottomLeft,
            })
              ? getQuadTree({
                  bounds: splittedBounds.bottomLeft,
                  rectangles: acc.bottomLeft?.data.concat(data) ?? [data],
                  treeNode: acc.bottomLeft ?? emptyQuadTree,
                  maxLevel: maxLevel - 1,
                })
              : acc.bottomLeft

            return {
              topRight,
              topLeft,
              bottomRight,
              bottomLeft,
              data: [],
            }
          }, treeNode)

          return newTree
        }
      }

      const getQuadTreeCollisions = ({ quadTree, maxLevel }) => {
        const flattenQuadTree = flatQuadTree(quadTree, maxLevel)
        const uniqueCollisions = {}
        flattenQuadTree.forEach((data) => {
          if (!Array.isArray(data)) {
            return
          }
          const entities = []
          let key = ''

          data.forEach(({ entity }) => {
            entities.push(entity)
            key = `${key},${entity}`
          })

          uniqueCollisions[key] = entities
        })

        return Object.values(uniqueCollisions)
      }

      const drawLine = ([x1, y1, x2, y2], color = 'rgb(255,0,0)') => {
        ctx.beginPath()
        ctx.moveTo(x1, canvasSize[1] - y1)
        ctx.lineTo(x2, canvasSize[1] - y2)

        ctx.strokeStyle = color
        ctx.lineWidth = 1
        ctx.stroke()
      }

      const drawRectangle = ([x1, y1, x2, y2], color = 'rgb(255,0,0)') => {
        drawLine([x1, y1, x1, y2], color)
        drawLine([x1, y2, x2, y2], color)
        drawLine([x2, y2, x2, y1], color)
        drawLine([x2, y1, x1, y1], color)
      }

      const drawQuadTree = (quadTree, bounds) => {
        let shouldSplit = false
        if (quadTree.topRight !== null) {
          shouldSplit = true
          drawQuadTree(
            quadTree.topRight,
            splitBounds({ bounds, position: 'topRight' }),
          )
        }
        if (quadTree.topLeft !== null) {
          shouldSplit = true
          drawQuadTree(
            quadTree.topLeft,
            splitBounds({ bounds, position: 'topLeft' }),
          )
        }
        if (quadTree.bottomRight !== null) {
          shouldSplit = true
          drawQuadTree(
            quadTree.bottomRight,
            splitBounds({ bounds, position: 'bottomRight' }),
          )
        }
        if (quadTree.bottomLeft !== null) {
          shouldSplit = true
          drawQuadTree(
            quadTree.bottomLeft,
            splitBounds({ bounds, position: 'bottomLeft' }),
          )
        }

        if (shouldSplit) {
          const boundHalfWidth = (bounds[2] - bounds[0]) / 2
          const boundHalfHeight = (bounds[3] - bounds[1]) / 2

          drawLine([
            bounds[0] + boundHalfWidth,
            bounds[1],
            bounds[2] - boundHalfWidth,
            bounds[3],
          ])
          drawLine([
            bounds[0],
            bounds[1] + boundHalfHeight,
            bounds[2],
            bounds[3] - boundHalfHeight,
          ])
        }
      }

      // DEMO data

      const rectangle1 = {
        entity: '1',
        rectangle: [20, 20, 60, 60],
      }
      const rectangle2 = {
        entity: '2',
        rectangle: [160, 160, 190, 190],
      }
      const rectangle3 = {
        entity: '3',
        rectangle: [250, 250, 280, 280],
      }
      const rectangle4 = {
        entity: '4',
        rectangle: [90, 90, 100, 100],
      }
      const rectangle5 = {
        entity: '5',
        rectangle: [130, 130, 140, 140],
      }
      const rectangle6 = {
        entity: '6',
        rectangle: [310, 500, 590, 590],
      }
      const rectangle7 = {
        entity: '7',
        rectangle: [305, 495, 400, 525],
      }

      const rectangles = [
        rectangle1,
        rectangle2,
        rectangle3,
        rectangle4,
        rectangle5,
        rectangle6,
        rectangle7,
      ]

      const maxLevel = 4
      const timeBeforeGetQuadTree = performance.now()
      const quadTree = getQuadTree({
        bounds: [0, 0, canvasSize[0], canvasSize[1]],
        rectangles,
        maxLevel,
      })
      const timeAfterGetQuadTree = performance.now()
      console.log(
        'quadTree generation time: ',
        timeAfterGetQuadTree - timeBeforeGetQuadTree,
        'ms',
      )

      const timeBeforeGetQuadTreeCollisions = performance.now()
      const collisions = getQuadTreeCollisions({ quadTree, maxLevel })
      const timeAfterGetQuadTreeCollisions = performance.now()

      console.log(
        'getQuadTreeCollisions time: ',
        timeAfterGetQuadTreeCollisions - timeBeforeGetQuadTreeCollisions,
        'ms',
      )

      console.log('quadTree: ', quadTree)
      console.log('getQuadTreeCollisions: ', collisions)

      drawQuadTree(quadTree, [0, 0, canvasSize[0], canvasSize[1]])

      rectangles.forEach(({ rectangle }) => {
        drawRectangle(rectangle, 'rgb(0,255,0)')
      })
    </script>
  </body>
</html>
